



早年接触过一些内存分配器，也曾经在项目里自己实现过，来回答一下。

free 函数唯一的参数是一个指针，而指针实际上是一个地址（整数）。

堆内存分配器大致可能有十余种算法实现，但归根结底都要在这个地址上做文章。内存分配的本质就是管理地址空间。



一个比较常见的实现，是在 `malloc` 的时候多分配 `sizeof(size_t)` 的内存，在这个 `size_t` 里面保存实际尺寸，并且在返回的时候，把地址向右偏移 `sizeof(size_t)`。`free` 的时候，先把入参地址向左偏移 `sizeof(size_t)`，就得到了实际分配地址，而此处解引用就能得到实际尺寸。于是这块内存就可以回收到管理结构中了。



再说一个我比较喜欢的实现，是基于 `chunk` 的管理，碎片率很低。把整个虚拟内存地址空间分成（看作）连续的 `chunk`，每一个 `chunk` 有固定的尺寸（一般是 `4k*n`，`n >= 1`），并且按自身对齐。以 `4k` 为例，那么第一个 `chunk` 是 `[0,4095]` 这一段，第二个 `chunk` 是 `[4096,8191]`，第三个 `[8192,12287]`…以此类推。每一次从虚拟内存上分配时都按 `chunk` 分配（因为虚拟内存是基于 `paging` 的，所以一定能保证按自身对齐），然后再在 `chunk` 上管理小尺寸分配。这样，在 `free` 的时候，只要把入参地址除以 chunk 的尺寸（实践中是地址对齐，用位运算即可），就能得到这个地址所属的 `chunk`。`chunk` 的头部存放了它的管理结构，所以能得知 free 的正确尺寸。`chunk` 管理上可以有不同的算法，一个比较有效的做法是 `freelist`：即把一个 `chunk` 再分成若干个相同尺寸的小块，并用指针把它们连接起来形成链表结构，`malloc` 和 `free` 都维护这个链表就行了。不同尺寸的 `malloc` 会落入不同的 `chunk`，而 `free` 总是能找到对的那个 `chunk`。