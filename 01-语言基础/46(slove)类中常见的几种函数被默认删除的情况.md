默认构造函数被删除（deleted）意味着该构造函数在类定义中被显式删除或间接删除，禁止了对象的默认构造。以下是几种导致默认构造函数被删除的常见情况：

1.  显式声明为删除：可以通过在类的定义中使用 `= delete` 显式地删除默认构造函数。例如

```C++
class MyClass { 
public:     
   MyClass() = delete; // 显式删除默认构造函数
};
```

2.  存在非静态常量成员且未提供默认初始值：如果类中存在非静态常量成员（如 const、引用或者没有提供默认初始值的成员），并且没有为这些成员提供默认初始值，那么默认构造函数将被自动删除。例如：

```C++
class MyClass {
public:
    int x;
    const int y; // 非静态常量成员
};
```



在上述示例中，由于 `const int y` 没有提供默认初始值，编译器将自动删除默认构造函数。

3.  存在只能用于初始化的成员变量：如果类中存在成员变量，其类型的默认构造函数是被删除或不可访问的（例如 private 构造函数），并且没有在类定义中提供初始值，那么默认构造函数也将被删除。例如

```C++
class AnotherClass {
private:
    AnotherClass() {} // 私有构造函数
};

class MyClass {
public:
    AnotherClass obj; // 具有私有构造函数的成员变量
};
```



在上述示例中，由于 `AnotherClass` 的构造函数是私有的且无默认构造函数，`MyClass` 的默认构造函数将被删除。

4.  基类的默认构造函数被删除：如果类派生自一个基类，而该基类的默认构造函数被删除，那么派生类的默认构造函数也将被删除。例如：

```C++
class Base {
public:
    Base() = delete; // 基类的默认构造函数被删除
};

class Derived : public Base { // 派生类
};
```

在上述示例中，由于 `Base` 的默认构造函数被删除，`Derived` 的默认构造函数也将被删除。

需要注意的是，当默认构造函数被删除时，使用该类的对象将会出现编译错误，除非提供了其他可用的构造函数。如果需要默认构造函数，**可以通过提供一个自定义的默认构造函数或满足删除原因的条件来解决该问题**。